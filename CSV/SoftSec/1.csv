Que vaut l'opération 2^{31} - 1 + 2 dans le cas d'un entier signé sur 32 bits ?,0,-2^{31} + 1,-2^{31},2^{31},-2^{31},none
Quelles fonctions de manipulation de chaînes de caractères sont des "suspectes habituelles" dans les Buffer Overflows car elles ne vérifient pas correctement la longueur de la chaîne ?,strcpy(),gets(),strncpy(),memcpy(),strcpy();gets(),none
Quels éléments sont stockés dans la pile (Stack) de la mémoire d'un programme ?,Les variables globales initialisées,Les variables locales,Les environnements de fonction durant les appels (stack frames),Les variables allouées dynamiquement (Heap),Les variables locales;Les environnements de fonction durant les appels (stack frames),none
Quelles sont les conséquences possibles du fait d'écraser l'adresse de retour (return address) lors d'un débordement de tampon ?,Pointer vers une instruction invalide,Déclencher une violation d'accès,Accéder à une adresse inexistante,Pointer vers le code malveillant de l'attaquant (shellcode),Pointer vers une instruction invalide;Déclencher une violation d'accès;Accéder à une adresse inexistante;Pointer vers le code malveillant de l'attaquant (shellcode),none
Quel est l'objectif principal de la protection par "Canaries" (valeurs sentinelles)?,Détecter les modifications inattendues des valeurs sur la pile,Randomiser les adresses des segments de mémoire,Empêcher l'exécution de code injecté dans la pile,Limiter la quantité de données copiées par les primitives libc,Détecter les modifications inattendues des valeurs sur la pile,none
Quel est le principe de la protection NX/W XOR X (Non Executable Memories)?,Insérer une valeur secrète après l'adresse de retour,Rendre le code non position-indépendant,Diviser les régions de mémoire de sorte qu'aucune région ne soit à la fois inscriptible et exécutable,Utiliser des gadgets ROP,Diviser les régions de mémoire de sorte qu'aucune région ne soit à la fois inscriptible et exécutable,none
Quelle technique d'attaque est spécifiquement conçue pour contourner les protections NX (W XOR X)?,Code injection (Shellcodes),Format string attacks,Return-to-libc attacks,Return Oriented Programming (ROP),Return-to-libc attacks;Return Oriented Programming (ROP),none
Quelles sont les trois propriétés nécessaires à l'existence d'une condition de concurrence (Race Condition)?,Objet Partagé (accédé par les deux flux),Changement d'État (au moins un flux modifie l'objet),Exécution mutuellement exclusive,Concurrence (au moins deux flux de contrôle),Objet Partagé (accédé par les deux flux);Changement d'État (au moins un flux modifie l'objet);Concurrence (au moins deux flux de contrôle),none
Dans quelles phases du processus d'utilisation d'un privilège les vulnérabilités par condition de concurrence surviennent-elles typiquement ?,Lorsqu'on exerce ce privilège,Lorsqu'on vérifie un privilège donné,Lorsqu'on utilise des types atomiques,Lorsqu'on effectue un appel système bloquant,Lorsqu'on exerce ce privilège;Lorsqu'on vérifie un privilège donné,none
Comment les conditions de concurrence peuvent-elles être éliminées, selon les sources ?,En augmentant la complexité du code,En utilisant uniquement des types atomiques,En évitant les appels systèmes,En rendant les opérations conflictuelles mutuellement exclusives,En rendant les opérations conflictuelles mutuellement exclusives,none
Quelles méthodes un attaquant peut-il utiliser pour améliorer ses chances d'exploiter une condition de concurrence ?,Utiliser une structure de répertoires profondément imbriquée combinée à des liens symboliques,Tenter l'attaque de manière répétée,Ralentir la machine ou le processus victime,Forger une adresse de retour,Utiliser une structure de répertoires profondément imbriquée combinée à des liens symboliques;Tenter l'attaque de manière répétée;Ralentir la machine ou le processus victime,none
Quel est le nom du triplet d'objectifs de sécurité fondamentaux pour un système d'information ?,Le Modèle OSI,La triade CIA (Confidentialité, Intégrité, Disponibilité),Le Modèle de l'Enigma,Le Modèle T.T.O.U,La triade CIA (Confidentialité, Intégrité, Disponibilité),none
Quel service de sécurité garantit la preuve d'origine et la protection de l'intégrité d'un message, empêchant de nier une transaction ?,La Confidentialité,L'Authentification des entités,L'Autorisation,La Non-répudiation,La Non-répudiation,none
Quel est le principal défi opérationnel de la cryptographie à clé symétrique ?,Le faible coût de calcul,L'échange de clés,L'impossibilité d'assurer la non-répudiation,La complexité des algorithmes,L'échange de clés,none
Quel est le rôle d'une fonction de hachage ?,Garantir la confidentialité,Servir au stockage sécurisé des mots de passe,Assurer la protection de l'intégrité,Associer un message de longueur quelconque à un message de longueur constante,Servir au stockage sécurisé des mots de passe;Assurer la protection de l'intégrité;Associer un message de longueur quelconque à un message de longueur constante,none
Quelles sont deux propriétés essentielles requises pour une fonction de hachage cryptographique ?,Résistance à la seconde préimage (2nd Preimage resistance),Résistance aux collisions (Collision-free),Hétérogénéité,Résistance à la préimage (Preimage resistance),Résistance à la seconde préimage (2nd Preimage resistance);Résistance aux collisions (Collision-free),none
Quelle est la définition de la possession (ownership) en Rust, liée au concept RAII ?,La responsabilité de déréférencer le pointeur,L'autorisation de créer des alias,Le fait d'avoir une sémantique COPY,La responsabilité de désallouer la mémoire (free/drop),La responsabilité de désallouer la mémoire (free/drop),none
Quelle sémantique s'applique en Rust aux valeurs qui peuvent contenir un pointeur vers le tas (comme String ou Vec<T>), sauf si un trait spécifique est implémenté ?,Sémantique d'aliasing,Sémantique MOVE,Sémantique COPY,Sémantique de réemprunt,Sémantique MOVE,none
Quelle est la règle fondamentale concernant l'aliasing des emprunts en Rust ?,Mutable => Partageable,Non Mutable => Partageable,Partagé => Non Mutable (et Mutable => Non Partageable),Partageable => Mutable,Partagé => Non Mutable (et Mutable => Non Partageable),none
Quelles sont les situations où l'utilisation du pointeur intelligent Box est utile en Rust ?,Manipuler une valeur dont le type n'est pas Sized,Définir une structure de données récursive (pour fixer la taille des nœuds),Gérer le comptage de références partagées,Remplacer un emprunt pour éviter les annotations de durée de vie,Manipuler une valeur dont le type n'est pas Sized;Définir une structure de données récursive (pour fixer la taille des nœuds),none
Quel mécanisme est utilisé par le pointeur intelligent Rc ?,La déréférencement automatique,L'emprunt mutable interne,Un Garbage Collector,Un compteur d'alias pour la ressource partagée,Un compteur d'alias pour la ressource partagée,none
Quelle est la principale différence de mutabilité entre le contenu d'un Box<T> (si Box est mutable) et le contenu d'un Rc<T> ?,Le contenu d'un Rc est toujours mutable,Le contenu d'un Rc n'implémente pas DerefMut car il est potentiellement partagé,Le contenu d'un Box est déréférencé automatiquement,Le contenu d'un Box est toujours immutable,Le contenu d'un Rc n'implémente pas DerefMut car il est potentiellement partagé,none
Quels traits un type de clé K doit-il implémenter pour être utilisé dans un HashMap<K, V> de la bibliothèque standard Rust ?,`Clone`,`Hash`,`Copy`,`Eq`,`Hash`;`Eq`,none
Étant donné l'implémentation de dup ci-dessous, quelle est la clause correcte à ajouter à la signature de la fonction pour permettre la compilation ?,where T: Default,where T: Sized,where T: Copy,where T: Clone,where T: Clone,https://i.postimg.cc/nzhDRXkG/q24.png
Quel trait doit être implémenté pour le type T afin que T utilise la sémantique COPY au lieu de la sémantique MOVE ?,`Drop`,`Sized`,`Clone`,`Copy`,`Copy`,none
Quelle est la valeur de sum et v après l'exécution du code ci-dessous ?,sum = 20, v = [1, 4],sum = 20, v = [3, 6],Erreur de compilation à cause du iter suivi de iter_mut,sum = 10, v = [3, 6],sum = 20, v = [3, 6],https://i.postimg.cc/9FCrJRQQ/q26.png
Que se passe-t-il à la fin de la fonction foo concernant la variable l ?,Elle est libérée par le mécanisme RAII car le Box est drop,Une erreur de compilation survient car elle a été empruntée,Elle est déplacée (MOVE) en dehors du scope,Elle est désallouée immédiatement par un free,Elle est libérée par le mécanisme RAII car le Box est drop,https://i.postimg.cc/gcDYcMGd/q27.png
Pourquoi le code suivant provoque-t-il une erreur de compilation ?,La String n'implémente pas le trait Copy,Le contenu d'un Rc ne peut pas être modifié car il n'implémente pas DerefMut,La variable rc n'est pas déclarée comme mut,La macro Rc::new doit être remplacée par Box::new,Le contenu d'un Rc ne peut pas être modifié car il n'implémente pas DerefMut,https://i.postimg.cc/L5CKtbsR/q28.png
Dans le contexte de l'exemple ci-dessous, si la ligne drop(i); est commentée, que se passe-t-il à l'exécution ?,La ligne let mut j = c.borrow_mut(); compile et s'exécute,Une erreur de compilation survient,Le programme affiche RefCell { value: <borrowed> },Le programme panique (runtime panic),Le programme panique (runtime panic),https://i.postimg.cc/qMPDPTWV/q29.png
Dans l'implémentation de increment pour SharedVec utilisant Cell, quelle ligne de code manque pour compléter l'opération de mise à jour (après avoir extrait, modifié la valeur, et avant que la fonction se termine) ?,self.val.replace(old_value),self.val.get(),self.val.set(old_value),old_value.clone(),self.val.set(old_value),https://i.postimg.cc/261KpSjb/q30.png
Pourquoi le code ci-dessous ne compile-t-il pas ?,La variable n n'est pas déclarée mut,Un emprunt mutable ne peut pas être partagé (règle PARTAGÉ => NON MUTABLE),La variable brw_prt2 doit être déclarée mut,brw_ptr est un emprunt mutable qui ne peut pas être réutilisé après avoir été déplacé vers brw_prt2,brw_ptr est un emprunt mutable qui ne peut pas être réutilisé après avoir été déplacé vers brw_prt2,https://i.postimg.cc/VvcB7fJw/q31.png
Que retourne la fonction upgrade appliquée à un Weak<T> si toutes les références fortes (Rc<T>) au même objet ont déjà été drop ?,Une nouvelle Rc<T> avec le compteur à 1,Un Option::None,Le Weak<T> lui-même,Un Option::Some(Rc<T>),Un Option::None,none
Quelle est la valeur de retour de seven après l'exécution du code Rust ci-dessous, compte tenu des implémentations du trait Add ?,Un type Nat avec val: 7,Un usize avec la valeur 7,Un type Nat avec val: 3,Une erreur de compilation car les opérations Add ne sont pas compatibles,Un usize avec la valeur 7,https://i.postimg.cc/5trMQG6b/q33.png
Quels modes de chiffrement de bloc (Block Cipher Mode) sont le plus susceptibles de limiter la propagation d'une erreur (corruption d'un seul bit dans C_i) au seul bloc P_i du texte clair correspondant, sans affecter les blocs suivants ?,Cipher Feedback (CFB),Cipher Block Chaining (CBC),Output Feedback (OFB),Electronic Code Book (ECB),Output Feedback (OFB);Electronic Code Book (ECB),none
Dans le cadre de la cryptographie à clé secrète, quelles sont les conséquences d'une erreur d'implémentation consistant à réutiliser un même Vecteur d'Initialisation (IV) pour chiffrer deux messages différents sous la même clé ?,L'exigence d'unicité de l'IV est secondaire tant que l'IV est généré aléatoirement.,Cela n'affecte que les chiffrements par blocs et est sans conséquence pour les modes basés sur le flux (comme OFB).,Cela provoque un débordement de tampon (*Buffer Overflow*) dans le processus de déchiffrement.,Cela permet à un attaquant, via une attaque par texte clair connu (*Known-plaintext attack*), de déchiffrer des parties des deux messages.,Cela permet à un attaquant, via une attaque par texte clair connu (*Known-plaintext attack*), de déchiffrer des parties des deux messages.,none
